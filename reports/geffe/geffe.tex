\documentclass[12pt]{article}
\usepackage[english,ukrainian]{babel}
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage{amsmath, graphicx, booktabs, listings, xcolor, inputenc, multirow, hyperref, pgfplots}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
\pgfplotsset{compat=1.17}

\title{\textbf{Побудова генератора псевдовипадкових послідовностей на лінійних регістрах зсуву (генератора Джиффі) та його кореляційний криптоаналіз}}
\author{}
\date{}

\begin{document}
\maketitle

\section{Мета роботи}
\quad Ознайомлення з деякими принципами побудови криптосистем на лінійних регістрах зсуву; практичне освоєння програмної реалізації лінійних регістрів зсуву (ЛРЗ); ознайомлення з методом кореляційного аналізу криптосистем на прикладі генератора Джиффі

\section{Хід роботи}
\subsection{Передпрограмний етап}
\quad Визначив мінімальну необхідну кількість знаків вихідної послідовності для знаходження заповення послідовності та значення порогу. Для цього була використана формула 4-6.
\begin{align*}
    C &= N_{p_1} + t_{1-\alpha} \sqrt{Np_{1}(1 - p_1)} = \frac{N}{4} + 2.33 \sqrt{\frac{3N}{16}} \\
    \beta M &< 1 \implies \beta = \frac{1}{2^{n_i}}, \quad n_i = \{30, 31\} \\
    C &= Np_{2} - t_{1 - \frac{1}{2^{n_i}}} \sqrt{Np_{2}(1 - p_2)} = \frac{N}{2} - 6 \sqrt{\frac{N}{4}} \\
    n &= 30: \\
    &\frac{N}{4} + 2.33 \sqrt{\frac{3N}{16}} = \frac{N}{2} - 6 \sqrt{\frac{N}{4}} \\ 
    &\implies N_1 = 258 \implies \\
    &\implies C_1 = 80.4 \\
    n &= 31: \\
    N_2 &= 265, \\ 
    C_2 &= 83.6; \\ 
    dummies: N_1 &= 222, C_1 = 71 \\ 
    N_2 &= 229, C_2 = 73
\end{align*}

\subsection{Реалізація класів LFSR та Geffe}
\quad В даній частині особливих труднрщів не було:
\begin{lstlisting}[language=Rust]
struct LFSR {
    state: u32,
    highest_bit: u8,
    taps: u32,
}

impl LFSR {
    fn new(taps: u32, degree: u8) -> LFSR {
        let highest_bit = degree - 1;
        LFSR {
            state: 0,
            highest_bit,
            taps,
        }
    }

    fn generate(&mut self, seed: u32, length: u64) -> Vec<u8> {
        self.state = seed;
        let mut output = vec![0u8; length as usize];

        for i in 0..length {
            output[i as usize] = (self.state & 1) as u8;
            self.state = (self.state >> 1)
                ^ (((self.state & self.taps).count_ones() & 1) << self.highest_bit);
        }

        output
    }
}

struct Geffe {
    lfsr1: LFSR,
    lfsr2: LFSR,
    lfsr3: LFSR,
}

impl Geffe {
    fn new(lfsr1: LFSR, lfsr2: LFSR, lfsr3: LFSR) -> Geffe {
        Geffe { lfsr1, lfsr2, lfsr3 }
    }

    fn generate(&mut self, seed1: u32, seed2: u32, seed3: u32, length: usize) -> Vec<u8> {
        let mut result = vec![0u8; length];

        let seq1 = self.lfsr1.generate(seed1, length as u64);
        let seq2 = self.lfsr2.generate(seed2, length as u64);
        let control = self.lfsr3.generate(seed3, length as u64);

        for i in 0..length {
            result[i] = if control[i] == 1 { seq1[i] } else { seq2[i] };
        }

        result
    }
}
\end{lstlisting}

\subsection{Знаходження кандидатів}
\quad А ось тут вже все не було так просто, довелось витратити досить велику к-ть часу на те, щоб зрозуміти як це має працювати з теоретичної точки зору та й програмна реалізація не була простою.
\begin{lstlisting}[language=Rust]
fn find_candidates(
    lfsr: &mut LFSR,
    target_seq: &[u8],
    required_len: usize,
    threshold: usize,
    degree: u8,
) -> Vec<(u32, usize)> {
    let cycle_len = (1u64 << degree) + required_len as u64;
    let mut current_candidate = 1u32;
    let generated_seq = lfsr.generate(current_candidate, cycle_len);

    let mut candidates = Vec::new();
    for j in 0..(1u64 << degree) {
        let mut discrepancy = 0;
        for i in 0..required_len {
            discrepancy += (generated_seq[j as usize + i] ^ target_seq[i]) as usize;
        }

        if discrepancy < threshold {
            candidates.push((current_candidate, discrepancy));
        }

        current_candidate = (current_candidate >> 1)
            ^ (((generated_seq[degree as usize + j as usize] as u32) << (degree - 1)) as u32);
    }

    candidates
}

fn find_best_candidate(candidates: &[(u32, usize)], required_len: usize) -> u32 {
    let mut best_candidate = candidates[0].0;
    let mut min_deviation = candidates[0].1 as f32 - 0.25 * required_len as f32;
    for &(candidate, discrepancy) in candidates {
        let deviation = discrepancy as f32 - 0.25 * required_len as f32;
        if deviation < min_deviation {
            min_deviation = deviation;
            best_candidate = candidate;
        }
    }

    best_candidate
}
\end{lstlisting}

\quad Використовучи функції задані вище, ми можемо визначати кандидатів для L1 та L2, тепер треба якимось чином отримати L3. І тут в гру вступає метод find lfsr3 candidate, наводити її реалізацію не буду, так як вона дуже схожа на функцію find candidate. Після цього, лишилось лише об'єднати все це добро в одне ціле, все це відбуваєтсья в функції main(), реалізацію, якої я також не буду наводити :)

\subsection{Результат роботи}
\begin{itemize}
    \item \textbf{Спрощений варіант}:
        \begin{tcolorbox}
        \\
LFSR1 finished with: 31 candidates \\
LFSR2 finished with: 2 candidates \\
LFSR3 finished \\

LFSR1 candidate:   13359614 00000000110010111101100111111110 \\ 
LFSR2 candidate:   30925695 00000001110101111110001101111111 \\
LFSR3 candidate:   70999587 00000100001110110101111000100011 \\ 
\\
Generated sequence: \\
011111101001111111110011100000000010101010101101101001000101000111 \\
001101101011000000101010100111010111000100011010111001100111001110 \\
111010010010101000011110110101111000010001100010000101100000100111 \\
001011111001111011010111111110111101000000001001000100001000001011 \\
011011111000101000011100000111110100011011010001011110001110101100 \\
001010111011110100101010001110000111100101001001011010110110111000 \\
100100011000011000000011001111001011111000000010001101001000011100 \\
000010110001011000011110000110011011010101101011111000001011011001 \\
111101011110101100000011100010010100110100101000100000011101101001 \\
111001011100100010000001010000010010011111010001111011001101101100 \\
110101000011000110000010000111010001010000011111111011100100011101 \\
010111001000110000000101110010111010100100001100101111001011001011 \\
001011001001100110110101011011111101111100011100111010101011001110 \\
101110101011101000110000000101100100010100111001011100111100011110 \\
010101110101011101010111000110011111001010010010001011100011100110 \\
001001000011000100100010010000011100100000101000111011111010100011 \\
101110010111011111010110000100010100010101010111010011001011110001 \\
010100101101100001101000010000000000110101010101001100001001010110 \\
011000000000101001010100111110010101110100100000100100101111011001 \\
010110011101110011010000100001010010110011001001110001111111111110 \\
100111001001000011011111101001110110100001101011011011111011101111 \\
101001000111110101010110110010101100101001010011101111110101111011 \\
000010111110010001010000000111000000010011101110101000000001100101 \\
101111001001010101101111010000010010011100111010111011011100110110 \\
101011101110011001100010110001011110101010110100001001110100111101 \\
000010011011111101000110100000100010101000000100011000111100001010 \\
100000101110000111011001010111101111110110101001000000010010001110 \\
111001101101100101000101111111010111111011111110100111010110000000 \\
010001101101001101111000111110010011010001100001001010011100101111 \\
011101010011001000001001011001000100011010100110111111010101110110 \\
000011111011111100100010000110011010101001111111110010100011100100 \\
11 \\
The generated sequence matches the target sequence. \\
Execution time: 16 seconds \\
        \end{tcolorbox}
    \item \textbf{Ускладнений варіант} \textcolor{red}{\textbf{працює неправильно}}:
        \\
LFSR1 finished with: 10 candidates \\
LFSR2 finished with: 698 candidates \\
LFSR3 finished \\

LFSR1 candidate:  761605600 00101101011001010010110111100000 \\ 
LFSR2 candidate: 1630242116 01100001001010111000010101000100 \\
LFSR3 candidate:          0 00000000000000000000000000000000 \\ 
\\
Generated sequence: \\
0010001010100001110101001000011001101111010111101110000101101010001 \\
0101101010011110101000111011011100011100110101110111110000011111111 \\
1010011011001001110011100000010100100001000011110111110001011000010 \\
1001011101001001111010011010110001011010000011010100100110011101000 \\
1010011001110000010101110101101100101011111001011101101100000100111 \\
0100110010110000001100100011101001010010011000110100011111010001100 \\
0001011110010111100101011101100101010110010101100111011000100111110 \\
0100111001011100011100011001100001111001011111111111101010110111011 \\
0010100000000010111100001100010011010000001010101110110111000100101 \\
0001011111011000001111100001101101010010001100111001110110000011100 \\
0011101011110111000110011111101111011010100111111010110001001010000 \\
1110011000101100111000011010111110101110100101111101100110100101101 \\
1010001010010001010010001000000101101100001101100001100100010100000 \\
1101100001101101000110110100110000110110000010111000001001011011000 \\
0110010101111001000010000011011010011101011000101001001100000100111 \\
0110011101100000101100100011100010111000110010100100011111111010111 \\
1110100110000111100000101101000101001011011101110010100010110110001 \\
0000110011100110110100000111001011010111101000001010011111001000110 \\
1010101001011001100110001110011111110001001010101011111110110000111 \\
1000011111110100001000110111011101110000101010100111000110011001111 \\
0101111110011111110101010110101101000110110000101111110001100010111 \\
0000110101010001111101110101111011001111101111001001101101010001011 \\
0010010110000100000111011010010000010011010010011110000100001001000 \\
1001000001101110100101000001100000100110001101000110100110110010001 \\
0111100101110010010000100011010101100101110000001010011100111100100 \\
1011110001011001111011011000001010111101001011010000001100101110101 \\
0100010001010001101001011011111011001101101110010001000010010001010 \\
0000011100011001010000011011010001111111101001101001100000101111000 \\
0010100100100101100101010111001011000000000100100111110111001001100 \\
0000100000011001001110000101100010010001101000011111010100111000001 \\
11001010111001011100111110011111001110 \\
The generated sequence does NOT match the target sequence. \\
Execution time: 629 seconds \\
\end{itemize}

\subsection {Час роботи}
\quad Якщо коротко, то час роботи простого варіанту 15-16 секунд, а ускладненого приблизно 640, правда відповідь, яку ми отримуємо в ускладненому варіанті є неправильною. Початково реалізація ж працювала близько 222 секунд для простого варіанту і 8750 секунд для ускладненого, але мені вдалось пришвидшити час роботи і я задоволений часом роботи :) Також я намагався використати багатопоточність для того, щоб пришвидшити час роботи, але мені не втілити цю ідею в реальність. 

\section{Висновок}
\quad За результатом роботи програми бачимо, бачимо логічну залежність між часом роботи програми та регістарми, які ми використовуємо. Теоретично, існує можливість ще трішки пришвидшити час роботи програми використовуючи багатопотоковість. 
\end{document}